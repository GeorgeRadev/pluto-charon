package pluto.managers;

import java.io.FileInputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.security.KeyStore;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import javax.net.ssl.KeyManager;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLServerSocketFactory;
import javax.net.ssl.TrustManager;

import pluto.charon.Utils;
import pluto.core.Log;

/**
 * jks file generated by: <br/>
 * keytool -genkey -keyalg RSA -alias selfsigned -keystore c:\desktop\pluto.jks
 * -storepass "pluto-charon" -validity 600 -keysize 2048
 */
public class SessionManager implements Runnable {
	public static final String SERVER_PORT = "PLUTO.Port";
	public static final String SERVER_KEYSTORE_TYPE = "PLUTO.KeystoreType";
	public static final String SERVER_CONTEXT_TYPE = "PLUTO.ContextType";
	public static final String SERVER_CERTIFICATE_FILE = "PLUTO.CertificateFile";
	public static final String SERVER_CERTIFICATE_PASSWORD = "PLUTO.CertificatePassword";

	private boolean running = false;
	private final int port;
	private final String sslKeystoreType;
	private final String sslContextType;
	private final String sslCertificateFile;
	private final String sslCertificatePassword;

	private ServerSocket socket;
	private final Thread serverThread;
	private final List<ClientSession> sessions = new ArrayList<ClientSession>(64);
	private final Map<ClientSession, Thread> sessionthreads = new ConcurrentHashMap<ClientSession, Thread>(64);
	private final DBManager dbManager;
	private final IAuthenticationManager authenticationManager;

	public SessionManager(Properties properties, IAuthenticationManager authenticationManager, DBManager dbManager) {
		String key;
		String portStr = properties.getProperty(key = SERVER_PORT, null);
		if (portStr == null) {
			Log.illegalState("Define " + key + " in property file");
		}
		{
			int portInt = 0;
			Integer portObj = Utils.toInteger(portStr);
			if (portObj == null) {
				Log.illegalState(SERVER_PORT + " = " + portStr + " should be a number");
			} else {
				portInt = portObj.intValue();
			}

			this.port = portInt;
		}

		{// load SSL info
			String _sslKeystoreType = properties.getProperty(SERVER_KEYSTORE_TYPE, null);
			String _sslContextType = properties.getProperty(SERVER_CONTEXT_TYPE, null);
			String _sslCertificateFile = properties.getProperty(SERVER_CERTIFICATE_FILE, null);
			String _sslCertificatePassword = properties.getProperty(SERVER_CERTIFICATE_PASSWORD, null);

			if (_sslKeystoreType != null && _sslKeystoreType.length() <= 0) {
				_sslKeystoreType = null;
			}
			if (_sslContextType != null && _sslContextType.length() <= 0) {
				_sslContextType = null;
			}
			if (_sslCertificateFile != null && _sslCertificateFile.length() <= 0) {
				_sslCertificateFile = null;
			}
			if (_sslCertificatePassword != null && _sslCertificatePassword.length() <= 0) {
				_sslCertificatePassword = null;
			}

			if (_sslKeystoreType != null || _sslContextType != null || _sslCertificateFile != null
					|| _sslCertificatePassword != null) {
				if (_sslKeystoreType == null || _sslContextType == null || _sslCertificateFile == null
						|| _sslCertificatePassword == null) {
					Log.warning("SSL DISABLED !!!!! To enable SSL socket comunication, define all parameters: "
							+ SERVER_KEYSTORE_TYPE + ", " + SERVER_CONTEXT_TYPE + ", " + SERVER_CERTIFICATE_FILE + ", "
							+ SERVER_CERTIFICATE_PASSWORD);
					_sslKeystoreType = null;
					_sslContextType = null;
					_sslCertificateFile = null;
					_sslCertificatePassword = null;
				}
			}
			sslKeystoreType = _sslKeystoreType;
			sslContextType = _sslContextType;
			sslCertificateFile = _sslCertificateFile;
			sslCertificatePassword = _sslCertificatePassword;
		}

		this.dbManager = dbManager;
		this.authenticationManager = authenticationManager;
		this.serverThread = new Thread(this);
	}

	public void start() throws IOException {
		if (sslKeystoreType != null || sslContextType != null || sslCertificateFile != null
				|| sslCertificatePassword != null) {
			try {
				// try SSL server socket layer
				KeyStore keyStore = KeyStore.getInstance(sslKeystoreType);
				keyStore.load(new FileInputStream(sslCertificateFile), sslCertificatePassword.toCharArray());

				TrustManager[] trustManagers = new TrustManager[1];
				trustManagers[0] = Utils.trustAllCert;// Utils.getX509TrustManager(keyStore);
				SSLContext sslContext = SSLContext.getInstance(sslContextType);

				KeyManager[] keyManagers = new KeyManager[1];
				keyManagers[0] = Utils.getX509KeyManager(keyStore, sslCertificatePassword);

				sslContext.init(keyManagers, trustManagers, null);
				SSLServerSocketFactory socketFactory = (SSLServerSocketFactory) sslContext.getServerSocketFactory();
				socket = (SSLServerSocket) socketFactory.createServerSocket(port);

			} catch (Exception e) {
				Log.error(e.getMessage(), e);
				Log.illegalState(e.getMessage());
			}
		} else {
			socket = new ServerSocket(port);
		}

		// run listening thread for handling client connections
		serverThread.start();
	}

	public void stop() throws IOException {
		socket.close();
		serverThread.interrupt();
		for (Thread sessionThread : sessionthreads.values()) {
			sessionThread.interrupt();
		}
		sessionthreads.clear();
	}

	public boolean isRunning() {
		return running;
	}

	@Override
	public void run() {
		Socket client = null;
		running = true;
		Log.log("server started at socket: " + socket);
		while (!Thread.interrupted()) {
			try {
				// attach new session
				client = socket.accept();
				ClientSession session = new ClientSession(client, this, dbManager, authenticationManager);
				sessions.add(session);
				Thread thread = new Thread(session);
				thread.setName("sesion thread: " + session.id + " connection: " + client);
				sessionthreads.put(session, thread);
				thread.start();

			} catch (SocketException e) {
				if (socket.isClosed()) {
					break;
				} else {
					Log.error("server thread error: ", e);
				}
			} catch (Throwable e) {
				Log.error("server thread error: ", e);
			}
			Thread.yield();
		}
		running = false;
	}

	public void detachSession(ClientSession plutoSession) {
		sessions.remove(plutoSession);
		sessionthreads.remove(plutoSession);
	}
}
